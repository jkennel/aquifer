# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title
#' impulse_function
#'
#' @description
#' Calculation of the impulse function from a well function.
#'
#' @param u well function
#' @param flow_time_interval time between flow rate measurements in samples
#'
#' @return impulse function for convolution
#'
#'
#' @export
#'
impulse_function <- function(u, flow_time_interval) {
    .Call('_aquifer_impulse_function', PACKAGE = 'aquifer', u, flow_time_interval)
}

#' @title
#' Ogata-Banks solution for 1-D flow.
#'
#' @description
#' Ogata, A., Banks, R.B., 1961. A solution of the differential equation of
#' longitudinal dispersion in porous media. U. S. Geol. Surv. Prof. Pap. 411-A.
#' 1-D, infinite source, uniform flow, constant parameters, no decay, no retardation
#'
#' @param D diffusion coefficient
#' @param v double velocity
#' @param C0 double concentration
#' @param x double x position
#' @param t double time
#'
#' @return ogata banks solution
#'
#' @export
#'
ogata_banks_ind <- function(D, v, C0, x, t) {
    .Call('_aquifer_ogata_banks_ind', PACKAGE = 'aquifer', D, v, C0, x, t)
}

#' @title
#' Ogata-Banks solution for 1-D flow (vectorized).
#'
#' @description
#' Ogata, A., Banks, R.B., 1961. A solution of the differential equation of
#' longitudinal dispersion in porous media. U. S. Geol. Surv. Prof. Pap. 411-A.
#' 1-D, infinite source, uniform flow, constant parameters, decay, retardation
#'
#' To have values match the excel sheet
#' https://www.civil.uwaterloo.ca/jrcraig/pdf/OgataBanks.xlsm the decay
#' coefficient needs to be scaled by the retardation coefficient.
#'
#' @param D doublediffusion coefficient
#' @param R double retardation coefficient
#' @param decay double decay coefficient
#' @param v double velocity
#' @param C0 double concentration
#' @param x vector x position
#' @param t vector time
#'
#' @return ogata banks solution each row is an x value and each column is a time
#'
#' @export
#'
ogata_banks <- function(D, R, decay, v, C0, x, t) {
    .Call('_aquifer_ogata_banks', PACKAGE = 'aquifer', D, R, decay, v, C0, x, t)
}

#' @title
#' rojstaczer
#'
#' @description
#' Modified Bessel function of second kind order 0
#'
#' @param frequency
#' @param radius_well
#' @param transmissivity
#' @param storage_confining
#' @param storage_aquifer
#' @param diffusivity_confining
#' @param diffusivity_vadose
#' @param thickness_confining
#' @param thickness_vadose
#' @param be
#' @param attenuations
#'
#' @return bessel function result
#'
#'
#' @export
rojstaczer <- function(frequency, radius_well, transmissivity, storage_confining, storage_aquifer, diffusivity_confining, diffusivity_vadose, thickness_confining, thickness_vadose, loading_efficiency, attenuation, gamma_term_a, gamma_term_b) {
    .Call('_aquifer_rojstaczer', PACKAGE = 'aquifer', frequency, radius_well, transmissivity, storage_confining, storage_aquifer, diffusivity_confining, diffusivity_vadose, thickness_confining, thickness_vadose, loading_efficiency, attenuation, gamma_term_a, gamma_term_b)
}

#' @title
#' rojstaczer_parallel
#'
#' @description
#' Modified Bessel function of second kind order 0
#'
#' @param frequency
#' @param radius_well
#' @param transmissivity
#' @param storage_confining
#' @param storage_aquifer
#' @param diffusivity_confining
#' @param diffusivity_vadose
#' @param thickness_confining
#' @param thickness_vadose
#' @param loading_efficiency
#' @param attenuations
#' @param gamma_term_a
#' @param gamma_term_b
#'
#' @return bessel function result
#'
#'
#' @export
rojstaczer_parallel <- function(frequency, radius_well, transmissivity, storage_confining, storage_aquifer, diffusivity_confining, diffusivity_vadose, thickness_confining, thickness_vadose, loading_efficiency, attenuation) {
    .Call('_aquifer_rojstaczer_parallel', PACKAGE = 'aquifer', frequency, radius_well, transmissivity, storage_confining, storage_aquifer, diffusivity_confining, diffusivity_vadose, thickness_confining, thickness_vadose, loading_efficiency, attenuation)
}

a_cpp <- function(x) {
    .Call('_aquifer_a_cpp', PACKAGE = 'aquifer', x)
}

b_cpp <- function(x) {
    .Call('_aquifer_b_cpp', PACKAGE = 'aquifer', x)
}

c_cpp <- function(x) {
    .Call('_aquifer_c_cpp', PACKAGE = 'aquifer', x)
}

#' Calculate equations 4 and 5 from bouwer, 1989
#'
#' @param rw
#' @param Le
#' @param Lw
#' @param H
#'
#' @return ln(Re/rw)
#'
bouwer_rice_abc <- function(rw, Le, Lw, H) {
    .Call('_aquifer_bouwer_rice_abc', PACKAGE = 'aquifer', rw, Le, Lw, H)
}

#' Calculate transmissivity with Bouwer-Rice solution
#'
#' @param time the elapsed time
#' @param drawdown the drawdown
#' @param radius_screen radius of the screen
#' @param radius_casing radius of the casing where the water level is
#' @param Le
#' @param Lw
#' @param H
#'
#' @return transmissivity from bouwer_rice
#'
#' @export
bouwer_rice <- function(time, drawdown, radius_screen, radius_casing, Le, Lw, H) {
    .Call('_aquifer_bouwer_rice', PACKAGE = 'aquifer', time, drawdown, radius_screen, radius_casing, Le, Lw, H)
}

slug_cbp_laplace_single <- function(p, radius_casing, radius_screen, radius, storativity = 1e-5, transmissivity = 1e-2, head_0 = 1) {
    .Call('_aquifer_slug_cbp_laplace_single', PACKAGE = 'aquifer', p, radius_casing, radius_screen, radius, storativity, transmissivity, head_0)
}

#' @title
#' slug_cbp_parallel
#'
#' @description
#' parallel boost function for the Bessel function
#'
#' @param p elapsed time since slug introduction
#' @param radius_casing radius of the casing where the water level is
#' @param radius_screen radius of the screened interval
#' @param radius radius from borehole center to calculate the response
#' @param storativity aquifer storativity
#' @param transmissivity aquifer transmissivity
#' @param head_0 height of introduced head change
#'
#' @return cbp solution
#'
#'
#' @export
#'
slug_cbp_parallel <- function(p, radius_casing, radius_screen, radius, storativity = 1e-5, transmissivity = 1e-2, head_0 = 1) {
    .Call('_aquifer_slug_cbp_parallel', PACKAGE = 'aquifer', p, radius_casing, radius_screen, radius, storativity, transmissivity, head_0)
}

hvorslev_shape <- function(x, d, r, l, case_num) {
    .Call('_aquifer_hvorslev_shape', PACKAGE = 'aquifer', x, d, r, l, case_num)
}

#' @title
#' bessel_k_single
#'
#' @description
#' boost function for the Bessel function
#'
#' @param x value for bessel function
#' @param nu order
#'
#' @return result of the bessel function
#'
#'
#' @export
#'
bessel_k_single <- function(x, nu) {
    .Call('_aquifer_bessel_k_single', PACKAGE = 'aquifer', x, nu)
}

#' @title
#' bessel_i_gamma_term
#'
#' @description
#' Modified Bessel function of first kind order 1
#'
#' @param x \code{numeric} value to evaluate
#' @param v \code{numeric} value to evaluate
#'
#' @return bessel function result
#'
#'
#' @export
bessel_i_gamma_term <- function(jj, v) {
    .Call('_aquifer_bessel_i_gamma_term', PACKAGE = 'aquifer', jj, v)
}

#' @title
#' bessel_i_complex
#'
#' @description
#' Modified Bessel function of first kind order 1
#'
#' @param x \code{numeric} value to evaluate
#' @param v \code{numeric} value to evaluate
#'
#' @return bessel function result
#'
#'
#' @export
bessel_i_complex_new <- function(x, v, gamma_term) {
    .Call('_aquifer_bessel_i_complex_new', PACKAGE = 'aquifer', x, v, gamma_term)
}

#' @title
#' bessel_k_complex for complex values
#'
#' @description
#' Modified Bessel function of second kind order 0
#'
#' @param x \code{numeric} value to evaluate
#'
#' @return bessel function result
#'
#'
#' @export
bessel_k_complex_opt <- function(x, gamma_term_a, gamma_term_b) {
    .Call('_aquifer_bessel_k_complex_opt', PACKAGE = 'aquifer', x, gamma_term_a, gamma_term_b)
}

#' @title
#' bessel_i_complex
#'
#' @description
#' Modified Bessel function of first kind order 1
#'
#' @param x \code{numeric} value to evaluate
#' @param v \code{numeric} value to evaluate
#'
#' @return bessel function result
#'
#'
#' @export
bessel_i_complex <- function(x, v) {
    .Call('_aquifer_bessel_i_complex', PACKAGE = 'aquifer', x, v)
}

#' @title
#' bessel_k_complex for complex values
#'
#' @description
#' Modified Bessel function of second kind order 0
#'
#' @param x \code{numeric} value to evaluate
#'
#' @return bessel function result
#'
#'
#' @export
bessel_k_complex <- function(x) {
    .Call('_aquifer_bessel_k_complex', PACKAGE = 'aquifer', x)
}

#' @title
#' bessel_k_complex_single for complex values
#'
#' @description
#' Modified Bessel function of second kind order 0
#'
#' @param x \code{numeric} value to evaluate
#'
#' @return bessel function result
#'
#'
#' @export
bessel_k_complex_single <- function(x) {
    .Call('_aquifer_bessel_k_complex_single', PACKAGE = 'aquifer', x)
}

#' @title
#' bessel_k_parallel
#'
#' @description
#' parallel boost function for the Bessel function
#'
#' @param x value for bessel function
#' @param nu order
#'
#' @return bessel k
#'
#'
#' @export
#'
bessel_k_parallel <- function(x, nu) {
    .Call('_aquifer_bessel_k_parallel', PACKAGE = 'aquifer', x, nu)
}

#' @title
#' bessel_k_complex_parallel
#'
#' @description
#' parallel boost function for the Bessel function
#'
#' @param x value for bessel function
#'
#' @return bessel k
#'
#'
#' @export
#'
bessel_k_complex_parallel <- function(x) {
    .Call('_aquifer_bessel_k_complex_parallel', PACKAGE = 'aquifer', x)
}

#' @title
#' bh_tgamma
#'
#' @description
#' Approximate the gamma function using Boost
#'
#' @param u numeric to evaluate the gamma function
#' @param a numeric flow dimension parameter
#'
#' @return the result of the gamma function
#'
#' @export
bh_tgamma <- function(u, a) {
    .Call('_aquifer_bh_tgamma', PACKAGE = 'aquifer', u, a)
}

#' @title
#' bh_gamma_neg
#'
#' @description
#' Approximate the gamma function when a is negative using Boost
#'
#' @param u numeric to evaluate the gamma function
#' @param a numeric flow dimension parameter
#'
#' @return the result of the gamma function
#'
#' @export
bh_gamma_neg <- function(u, a) {
    .Call('_aquifer_bh_gamma_neg', PACKAGE = 'aquifer', u, a)
}

#' @title
#' gamma_der
#'
#' @description
#' Derivative of the gamma function.
#'
#' @param u numeric to evaluate the gamma function
#' @param a numeric flow dimension parameter
#'
#' @return the result of the gamma function
#'
#' @export
gamma_der <- function(u, a) {
    .Call('_aquifer_gamma_der', PACKAGE = 'aquifer', u, a)
}

#' @title
#' exp_int_single
#'
#' @description
#' Calculate the exponential integral using Boost
#'
#' @param u value of the Theis u
#' @param a not used (flow dimension)
#'
#' @return exponential integral
#'
#' @useDynLib aquifer
#' @import RcppParallel
#' @importFrom Rcpp evalCpp
#'
#' @export
#'
exp_int_single <- function(u, a) {
    .Call('_aquifer_exp_int_single', PACKAGE = 'aquifer', u, a)
}

#' @title
#' grf_parallel
#'
#' @description
#' Parallel vector version of the exponential integral
#'
#' @param u value of the Theis u
#' @param a flow dimension
#'
#' @return exponential integral
#'
#'
#' @export
#'
grf_parallel <- function(u, a) {
    .Call('_aquifer_grf_parallel', PACKAGE = 'aquifer', u, a)
}

#' @title
#' hantush_well_single
#'
#' @description
#' Result of the hantush well function
#'
#' @param u value of the Theis u
#' @param b the leakance
#' @param n_terms the number of terms used in the hantush approximation
#'
#'
#' @return hantush well function
#'
#'
#' @export
#'
hantush_well_single <- function(u, b, n_terms) {
    .Call('_aquifer_hantush_well_single', PACKAGE = 'aquifer', u, b, n_terms)
}

#' @title
#' hantush_well_single
#'
#' @description
#' Parallel version of the hantush well function
#'
#'
#' @param u (vector) value of the Theis u
#' @param b the leakance
#' @param n_terms the number of terms used in the hantush approximation
#'
#'
#' @return hantush well function
#'
#'
#' @export
#'
hantush_well_parallel <- function(u, b, n_terms) {
    .Call('_aquifer_hantush_well_parallel', PACKAGE = 'aquifer', u, b, n_terms)
}

weeks_1979 <- function(lag, D, L, precision = 1e-8, inverse = TRUE) {
    .Call('_aquifer_weeks_1979', PACKAGE = 'aquifer', lag, D, L, precision, inverse)
}

#' @title
#' vadose_response
#'
#' @description
#' weeks_1979 1-D air diffusivity
#'
#' @param time \code{numeric} value of elapsed time
#' @param D \code{numeric} unsaturated zone air diffusivity
#' @param L \code{numeric} unsaturated zone thickness
#' @param precision \code{numeric} precision of solution
#' @param inverse \code{logical} inverse water level relationship
#'
#' @return weeks 1979 model
#'
#'
#' @export
#'
vadose_response <- function(time, D, L, precision = 1e-08, inverse = TRUE) {
    .Call('_aquifer_vadose_response', PACKAGE = 'aquifer', time, D, L, precision, inverse)
}

#' @title
#' well_function_coefficient
#'
#' @description
#' Calculation Coefficient Q/(4 pi * T)
#'
#' @param flow_rate well flow rates
#' @param transmissivity aquifer transmissivity
#'
#' @return coefficient for Theis and Hantush well function
#'
#'
#' @export
#'
well_function_coefficient <- function(flow_rate, transmissivity) {
    .Call('_aquifer_well_function_coefficient', PACKAGE = 'aquifer', flow_rate, transmissivity)
}

#' @title
#' hantush_epsilon
#'
#' @description
#' Calculation of r^2/(4B^2)
#'
#' @param radius distance to monitoring well
#' @param leakage aquifer transmissivity
#'
#' @return coefficient Hantush well function
#'
#'
#' @export
#'
hantush_epsilon <- function(radius, leakage) {
    .Call('_aquifer_hantush_epsilon', PACKAGE = 'aquifer', radius, leakage)
}

#' @title
#' grf_coefficient
#'
#' @description
#' Coefficient for the grf without pumping
#'
#' @param flow_rate (vector) the flow rate
#' @param radius (double) distance to center of source
#' @param K (double) hydraulic conductivity of the fracture system
#' @param thickness (double) thickness
#' @param flow_dimension (double) flow dimension
#'
#' @return coefficient
#'
#'
#' @export
#'
grf_coefficient <- function(flow_rate, radius, K, thickness, flow_dimension) {
    .Call('_aquifer_grf_coefficient', PACKAGE = 'aquifer', flow_rate, radius, K, thickness, flow_dimension)
}

#' @title
#' theis_u_time
#'
#' @description
#' Calculation of Theis u
#'
#' @param radius distance to monitoring interval
#' @param storativity aquifer storativity
#' @param transmissivity aquifer transmissivity
#' @param time prediction times
#'
#' @return u for well function
#'
#'
#' @export
#'
theis_u_time <- function(radius, storativity, transmissivity, time) {
    .Call('_aquifer_theis_u_time', PACKAGE = 'aquifer', radius, storativity, transmissivity, time)
}

#' @title
#' grf_u_time
#'
#' @description
#' Calculation of grf u
#'
#' @param radius distance to monitoring interval
#' @param storativity aquifer storativity
#' @param K aquifer hydraulic conductivity
#' @param time prediction times
#'
#' @return u for well function
#'
#'
#' @export
#'
grf_u_time <- function(radius, storativity, K, time) {
    .Call('_aquifer_grf_u_time', PACKAGE = 'aquifer', radius, storativity, K, time)
}

#' @title
#' well_function_convolve
#'
#' @description
#' Parallel convolution in the time domain
#'
#' @param flow_time_interval time between flow rate measurements in samples
#' @param coefs well coeffiicents
#' @param u well impuse function
#'
#' @return impulse function for convolution
#'
#'
#' @export
#'
well_function_convolve <- function(flow_time_interval, coefs, u) {
    .Call('_aquifer_well_function_convolve', PACKAGE = 'aquifer', flow_time_interval, coefs, u)
}

#' @title
#' grf_time_parallel
#'
#' @description
#' Parallel convolution of GRF well function and flow rates in the time domain.
#' Time series needs to be regularily spaced and so are the flow rates.  Some
#' performance gains can be achieved if the number of flow rate does not change
#' for each time.
#'
#' @param radius distance to monitoring interval
#' @param storativity aquifer storativity
#' @param K aquifer hydraulic conductivity
#' @param thickness aquifer thickness
#' @param time prediction times
#' @param flow_rate well flow rates
#' @param flow_time_interval time between flow rate measurements in samples
#' @param flow_dimension flow dimension
#'
#' @return theis solution for multiple pumping scenario
#'
#'
#' @export
#'
grf_time_parallel <- function(radius, storativity, K, thickness, time, flow_rate, flow_time_interval, flow_dimension) {
    .Call('_aquifer_grf_time_parallel', PACKAGE = 'aquifer', radius, storativity, K, thickness, time, flow_rate, flow_time_interval, flow_dimension)
}

#' @title
#' hantush_time_parallel
#'
#' @description
#' Parallel convolution of hantush well function and flow rates in the time domain.
#' Time series needs to be regularily spaced.
#'
#' @param radius distance to monitoring interval
#' @param storativity aquifer storativity
#' @param transmissivity aquifer transmissivity
#' @param leakage hantush leakage
#' @param time prediction times
#' @param flow_rate well flow rates
#' @param flow_time_interval time between flow rate measurements in samples
#' @param n_terms number of terms to use in Hantush solution.  More is more precise but slower.
#'
#' @return hantush jacob solution for multiple pumping scenario
#'
#'
#' @export
#'
hantush_time_parallel <- function(radius, storativity, transmissivity, leakage, time, flow_rate, flow_time_interval, n_terms) {
    .Call('_aquifer_hantush_time_parallel', PACKAGE = 'aquifer', radius, storativity, transmissivity, leakage, time, flow_rate, flow_time_interval, n_terms)
}

#' @title
#' grf
#'
#' @description
#' Parallel convolution of GRF well function and flow rates in the time domain.
#' Time series needs to be regularily spaced and so are the flow rates.  Some
#' performance gains can be achieved if the number of flow rate does not change
#' for each time.
#'
#' @param radius distance to monitoring interval
#' @param storativity aquifer storativity
#' @param transmissivity aquifer transmissivity
#' @param leakage hantush leakage
#' @param time prediction times
#' @param flow_rate well flow rates
#' @param flow_rate_times time of flow rate changes
#' @param n_terms number of terms to use in Hantush solution.  More is more precise but slower.
#'
#' @return theis solution for multiple pumping scenario
#'
#'
#' @export
#'
hantush <- function(radius, storativity, transmissivity, leakage, time, flow_rate, flow_rate_times, n_terms) {
    .Call('_aquifer_hantush', PACKAGE = 'aquifer', radius, storativity, transmissivity, leakage, time, flow_rate, flow_rate_times, n_terms)
}

#' @title
#' grf
#'
#' @description
#' Parallel convolution of GRF well function and flow rates in the time domain.
#' Time series needs to be regularily spaced and so are the flow rates.  Some
#' performance gains can be achieved if the number of flow rate does not change
#' for each time.
#'
#' @param radius distance to monitoring interval
#' @param storativity aquifer storativity
#' @param K aquifer hydraulic conductivity
#' @param thickness aquifer thickness
#' @param time prediction times
#' @param flow_rate well flow rates
#' @param flow_rate_times times where flow rates change
#' @param flow_dimension flow dimension
#'
#' @return theis solution for multiple pumping scenario
#'
#'
#' @export
#'
grf <- function(radius, storativity, K, thickness, time, flow_rate, flow_rate_times, flow_dimension) {
    .Call('_aquifer_grf', PACKAGE = 'aquifer', radius, storativity, K, thickness, time, flow_rate, flow_rate_times, flow_dimension)
}

